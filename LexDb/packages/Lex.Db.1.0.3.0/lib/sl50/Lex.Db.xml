<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lex.Db</name>
    </assembly>
    <members>
        <member name="T:Lex.Db.Ctor`1">
            <summary>
            Extreme fast generic constructor. 
            </summary>
            <remarks>
            About 20 times faster than "new T()", because the last one uses slow reflection-based Activator.CreateInstance internally.
            </remarks>
            <typeparam name="T">Type to construct</typeparam>
        </member>
        <member name="F:Lex.Db.Ctor`1.New">
            <summary>
            Generic <typeparamref name="T"/> constructor function
            </summary>
        </member>
        <member name="T:Lex.Db.Ctor`2">
            <summary>
            Extreme fast generic constructor. Constructs <typeparamref name="T"/>, but returns <typeparamref name="R"/>. So <typeparamref name="T"/> must be direct assignable to <typeparamref name="R"/>.
            </summary>
            <remarks>
            About 20 times faster than "new T()", because the last one uses slow reflection-based Activator.CreateInstance internally.
            </remarks>
            <typeparam name="T">Type to construct</typeparam>
            <typeparam name="R">Type to return</typeparam>
        </member>
        <member name="F:Lex.Db.Ctor`2.New">
            <summary>
            Generic <typeparamref name="T"/> constructor function, returning <typeparamref name="T"/> as <typeparamref name="R"/> type
            </summary>
        </member>
        <member name="T:Lex.Db.DbInstance">
            <summary>
            Database access and management
            </summary>
        </member>
        <member name="M:Lex.Db.DbInstance.#ctor(System.String)">
            <summary>
            Creates database instance with specified path
            </summary>
            <param name="path">Path to database storage folder (relative to default app storage)</param>
        </member>
        <member name="M:Lex.Db.DbInstance.Initialize">
            <summary>
            Initializes database
            </summary>
        </member>
        <member name="M:Lex.Db.DbInstance.HasMap(System.Type)">
            <summary>
            Indicates whether specified entity type is mapped in database
            </summary>
            <param name="type">Entity type</param>
            <returns>True if type is mapped in database, false otherwise</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.HasMap``1">
            <summary>
            Indicates whether specified entity type is mapped in database
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <returns>True if type is mapped in database, false otherwise</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Map``1">
            <summary>
            Maps specified entity type in database and provides mapping infrastructure
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <returns>Entity T mapping configurator</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Map``1(System.Func{``0})">
            <summary>
            Maps specified entity type in database and provides mapping infrastructure
            </summary>
            <typeparam name="T">Entity prototype</typeparam>
            <param name="ctor">Entity implementation constructor</param>
            <returns>Entity T mapping configurator</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Map``2">
            <summary>
            Maps specified entity type in database and provides mapping infrastructure
            </summary>
            <typeparam name="T">Entity prototype</typeparam>
            <typeparam name="TClass">Entity implementation type</typeparam>
            <returns>Entity T mapping configurator</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Table``1">
            <summary>
            Provides database table infrastructure to read/write/query entities
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Lex.Db.DbInstance.BulkRead(System.Action)">
            <summary>
            Performs specified action inside read transaction scope
            </summary>
            <param name="action">Action to execute inside read transaction scope</param>
        </member>
        <member name="M:Lex.Db.DbInstance.BulkWrite(System.Action)">
            <summary>
            Performs specified action inside write transcantion scope.
            </summary>
            <param name="action">Action to execute inside write transaction scope</param>
        </member>
        <member name="M:Lex.Db.DbInstance.LoadAll``1">
            <summary>
            Loads all entities of specified entity type
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <returns>Array of all entities</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.LoadByKey``1(System.Object)">
            <summary>
            Loads an entity of specified entity type by specified PK value
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <param name="key">PK value as object</param>
            <returns>Entity identified by the PK value, if any</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.LoadByKey``2(``1)">
            <summary>
            Loads an entity of specified entity type by specified PK value
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="key">PK value</param>
            <returns>Entity identified by the PK value, if any</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Count``1">
            <summary>
            Determines number of entities stored in specified entity table
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <returns>Number of entities stored in specified entity table</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Save``1(``0)">
            <summary>
            Saves specified entity, adding or updating as needed
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <param name="item">Entity to upsert into table</param>
        </member>
        <member name="M:Lex.Db.DbInstance.Save``1(``0[])">
            <summary>
            Saves specified entity sequence, adding or updating as needed
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <param name="items">Entity sequence to upsert into table</param>
        </member>
        <member name="M:Lex.Db.DbInstance.Save``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Saves specified entity sequence, adding or updating as needed
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <param name="items">Entity sequence to upsert into table</param>
        </member>
        <member name="M:Lex.Db.DbInstance.DeleteByKeys``2(System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Deletes entities specified by key sequence
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <typeparam name="K">Type of the primary key</typeparam>
            <param name="keys">Sequence of key values to specify entities to delete</param>
            <returns>Returns count of the deleted entities</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.DeleteByKey``1(System.Object)">
            <summary>
            Deletes entity specified by PK value
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <param name="key">Key of entity to delete</param>
            <returns>True if entity was deleted</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.DeleteByKey``2(``1)">
            <summary>
            Deletes entity specified by PK value
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="key">Key of entity to delete</param>
            <returns>True if entity was deleted</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Delete``1(``0)">
            <summary>
            Deletes specified entity
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <param name="item">Entity to delete</param>
            <returns>True if entity was deleted</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Refresh``1(``0)">
            <summary>
            Refreshes specified entity from disk
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <param name="item">Entity to refresh</param>
            <returns>Same entity, updated from disk</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.AllKeys``2">
            <summary>
            Lists all current key values for specified entity type
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <typeparam name="K">Type of the PK</typeparam>
            <returns>List of all current key values for specified entity type</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.AllKeys``1">
            <summary>
            Lists all current key values 
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <returns>Sequence of key values for specified entity type</returns>
        </member>
        <member name="M:Lex.Db.DbInstance.Flush">
            <summary>
            Flushes underlying database storage
            </summary>
        </member>
        <member name="M:Lex.Db.DbInstance.Flush``1">
            <summary>
            Flushes the underlying table storage
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
        </member>
        <member name="M:Lex.Db.DbInstance.Compact">
            <summary>
            Compacts all data files in database
            </summary>
        </member>
        <member name="M:Lex.Db.DbInstance.Purge">
            <summary>
            Clears the database
            </summary>
        </member>
        <member name="M:Lex.Db.DbInstance.Purge``1">
            <summary>
            Clears the specified entity table
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
        </member>
        <member name="M:Lex.Db.DbInstance.Dispose">
            <summary>
            Disposes database
            </summary>
        </member>
        <member name="P:Lex.Db.DbInstance.Path">
            <summary>
            Indicates path to database storage folder (relative to default app storage)
            </summary>
        </member>
        <member name="T:Lex.Db.DbTable">
            <summary>
            Abstract database table interface
            </summary>
        </member>
        <member name="M:Lex.Db.DbTable.Count">
            <summary>
            Determines count of entities stored in the table
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lex.Db.DbTable.Purge">
            <summary>
            Removes all entities from the table
            </summary>
        </member>
        <member name="M:Lex.Db.DbTable.Compact">
            <summary>
            Compacts the data stream of the table
            </summary>
        </member>
        <member name="M:Lex.Db.DbTable.Flush">
            <summary>
            Flushed the underlying data and index streams to disk
            </summary>
        </member>
        <member name="M:Lex.Db.DbTable.AllKeys``1">
            <summary>
            Gathers all currently used PK values from PK index
            </summary>
            <typeparam name="K">Type of the key</typeparam>
            <returns>Typed list of key values</returns>
        </member>
        <member name="M:Lex.Db.DbTable.AllKeys">
            <summary>
            Gathers all currently used PK values from PK index
            </summary>
            <returns>Untyped IEnumerable of key values</returns>
        </member>
        <member name="M:Lex.Db.DbTable.GetMinKey``1">
            <summary>
            Determines minimal PK value from PK index,
            returns default(K) if table is empty
            </summary>
            <typeparam name="K">Type of the key</typeparam>
            <returns>Minimal PK value</returns>
        </member>
        <member name="M:Lex.Db.DbTable.GetMaxKey``1">
            <summary>
            Determines maximal PK value from PK index,
            returns default(K) if table is empty
            </summary>
            <typeparam name="K">Type of the key</typeparam>
            <returns>Maximal PK value</returns>
        </member>
        <member name="M:Lex.Db.DbTable.DeleteByKey``1(``0)">
            <summary>
            Deletes single entity by PK value
            </summary>
            <typeparam name="K">Type of the key</typeparam>
            <param name="key">Entity PK value</param>
            <returns>Returns true if record was deleted, false otherwise</returns>
        </member>
        <member name="M:Lex.Db.DbTable.DeleteByKeys``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Deletes set of entities, determined by their PK values
            </summary>
            <typeparam name="K">Type of the key</typeparam>
            <param name="keys">Enumeration of entity PK values</param>
            <returns></returns>
        </member>
        <member name="P:Lex.Db.DbTable.Type">
            <summary>
            Type of the table entity class
            </summary>
        </member>
        <member name="P:Lex.Db.DbTable.Name">
            <summary>
            Name of the table
            </summary>
        </member>
        <member name="P:Lex.Db.DbTable.Item(System.String)">
            <summary>
            Specifies key/values pairs of the table metadata 
            </summary>
            <param name="property">Metadata property name</param>
            <returns>Value of the named metadata property</returns>
        </member>
        <member name="T:Lex.Db.DbTable`1">
            <summary>
            Typed database table 
            </summary>
            <typeparam name="T">Table entity class</typeparam>
        </member>
        <member name="M:Lex.Db.DbTable`1.Count">
            <summary>
            Determines number of entities stored in the table
            </summary>
            <returns>Number of entities stored in the table</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.AllKeys``1">
            <summary>
            Lists all current key values 
            </summary>
            <typeparam name="K">Type of the PK</typeparam>
            <returns>List of all current key values</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.AllKeys">
            <summary>
            Lists all current keys 
            </summary>
            <returns>Sequence of key values</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LoadAll">
            <summary>
            Loads all entities  
            </summary>
            <returns>Array of all entities</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LoadAll``1(System.String,``0)">
            <summary>
            Loads entities by specified index and key value 
            </summary>
            <returns>List of all entities with specified key value</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LazyLoad``1">
            <summary>
            Lazy load via primary key
            </summary>
            <typeparam name="K">Primary key type</typeparam>
            <returns>List of lazy instances</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LazyLoad``1(System.String)">
            <summary>
            Lazy load via normal index
            </summary>
            <typeparam name="I1">Index type parameter</typeparam>
            <param name="index">Name of the index (case insensitive)</param>
            <returns>List of lazy instances</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LazyLoad``1(System.String,``0)">
            <summary>
            Lazy load via normal index
            </summary>
            <typeparam name="I1">Index type parameter</typeparam>
            <param name="index">Name of the index (case insensitive)</param>
            <param name="key">Key value</param>
            <returns>List of lazy instances</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LazyLoad``2(System.String,``0,``1)">
            <summary>
            Lazy load via normal index
            </summary>
            <typeparam name="I1">Index type first parameter</typeparam>
            <typeparam name="I2">Index type second parameter</typeparam>
            <param name="index">Name of the index (case insensitive)</param>
            <param name="key1">Value for first key component</param>
            <param name="key2">Value for second key component</param>
            <returns>List of lazy instances</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LazyLoad``2(System.String)">
            <summary>
            Lazy load via normal index by two columns
            </summary>
            <typeparam name="I1">Index type first parameter</typeparam>
            <typeparam name="I2">Index type second parameter</typeparam>
            <param name="index">Name of the index (case insensitive)</param>
            <returns>List of lazy instances</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LazyLoad``3(System.String,``0,``1,``2)">
            <summary>
            Lazy load via normal index
            </summary>
            <typeparam name="I1">Index type first parameter</typeparam>
            <typeparam name="I2">Index type second parameter</typeparam>
            <typeparam name="I3">Index type second parameter</typeparam>
            <param name="index">Name of the index (case insensitive)</param>
            <param name="key1">First component of key value</param>
            <param name="key2">Second component of key value</param>
            <param name="key3">Third component of key value</param>
            <returns>List of lazy instances</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LazyLoad``3(System.String)">
            <summary>
            Lazy load via normal index by three columns
            </summary>
            <typeparam name="I1">Index type first parameter</typeparam>
            <typeparam name="I2">Index type second parameter</typeparam>
            <typeparam name="I3">Index type third parameter</typeparam>
            <param name="index">Name of the index (case insensitive)</param>
            <returns>List of lazy instances</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LoadByKey``1(``0)">
            <summary>
            Loads an entity by specified PK value
            </summary>
            <typeparam name="K">Type of the primary key</typeparam>
            <param name="key">PK value</param>
            <returns>Entity identified by the PK value, if any</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.LoadByKeys``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Bulk load specified instances by key
            </summary>
            <typeparam name="K">Type of the primary key</typeparam>
            <param name="keys">Sequence of keys to load</param>
            <param name="yieldNotFound">Specifies that missed keys will be returned as nulls</param>
            <returns>List of corresponding instances</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.Refresh(`0)">
            <summary>
            Refreshes specified entity from disk
            </summary>
            <param name="item">Entity to refresh</param>
            <returns>Same entity, updated from disk</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.Save(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Saves specified entity sequence, adding or updating as needed
            </summary>
            <param name="items">Entity sequence to upsert into table</param>
        </member>
        <member name="M:Lex.Db.DbTable`1.Save(`0)">
            <summary>
            Saves specified entity, adding or updating as needed
            </summary>
            <param name="item">Entity to upsert into table</param>
        </member>
        <member name="M:Lex.Db.DbTable`1.ReadIndexes(System.IO.Stream)">
            <summary>
            Fast check index header and reloads it when changed
            </summary>
        </member>
        <member name="M:Lex.Db.DbTable`1.Flush">
            <summary>
            Flushes the underlying table storage
            </summary>
        </member>
        <member name="M:Lex.Db.DbTable`1.DeleteByKey``1(``0)">
            <summary>
            Deletes entity specified by key
            </summary>
            <typeparam name="K">Type of the primary key</typeparam>
            <param name="key">Key of entity to delete</param>
            <returns>True if entity was deleted</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.DeleteByKeys``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Deletes entities specified by key sequence 
            </summary>
            <typeparam name="K">Type of the primary key</typeparam>
            <param name="keys">Key sequence to delete</param>
            <returns>Count of the deleted entities</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.Delete(`0)">
            <summary>
            Deletes specified entity
            </summary>
            <param name="item">Entity to delete</param>
            <returns>True is entity was deleted</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.Delete(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Deletes entities specified by the sequence 
            </summary>
            <param name="items">Sequence of entities to delete</param>
        </member>
        <member name="M:Lex.Db.DbTable`1.Compact">
            <summary>
            Compacts data file of the table
            </summary>
        </member>
        <member name="M:Lex.Db.DbTable`1.Purge">
            <summary>
            Clears the table
            </summary>
        </member>
        <member name="M:Lex.Db.DbTable`1.GetMinKey``1">
            <summary>
            Determines minimal PK value from PK index,
            returns default(K) if table is empty
            </summary>
            <typeparam name="K">Type of the key</typeparam>
            <returns>Minimal PK value</returns>
        </member>
        <member name="M:Lex.Db.DbTable`1.GetMaxKey``1">
            <summary>
            Determines maximal PK value from PK index,
            returns default(K) if table is empty
            </summary>
            <typeparam name="K">Type of the key</typeparam>
            <returns>Maximal PK value</returns>
        </member>
        <member name="P:Lex.Db.DbTable`1.Type">
            <summary>
            Type of the table entity class
            </summary>
        </member>
        <member name="P:Lex.Db.DbTable`1.Name">
            <summary>
            Name of the table
            </summary>
        </member>
        <member name="P:Lex.Db.DbTable`1.Item(System.String)">
            <summary>
            Specifies key/values pairs of the table metadata 
            </summary>
            <param name="property">Metadata property name</param>
            <returns>Value of the named metadata property</returns>
        </member>
        <member name="T:Lex.Db.DbTableAsync">
            <summary>
            Asynchronous extensions for DbTable
            </summary>
        </member>
        <member name="M:Lex.Db.DbTableAsync.LoadAllAsync``1(Lex.Db.DbTable{``0})">
            <summary>
            Asynchronously loads all entities from table 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <param name="table">Table of the entity class</param>
            <returns>Awaitable Task with array of entities in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.CountAsync``1(Lex.Db.DbTable{``0})">
            <summary>
            Asynchronously counts all entities from table 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <param name="table">Table of the entity class</param>
            <returns>Awaitable Task with count in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.AllKeysAsync``1(Lex.Db.DbTable)">
            <summary>
            Asynchronously loads all PK values from PK index 
            </summary>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="table">Table of the entity class</param>
            <returns>Awaitable Task with list of PK values in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.AllKeysAsync(Lex.Db.DbTable)">
            <summary>
            Asynchronously loads all PK values from PK index 
            </summary>
            <param name="table">Table of the entity class</param>
            <returns>Awaitable Task with enumeration of untyped PK values in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.LoadAllAsync``2(Lex.Db.DbTable{``0},System.String,``1)">
            <summary>
            Asynchronously loads entities by specified index and value 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <typeparam name="I1">Type of the indexed value</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="index">Name of the index</param>
            <param name="key">Typed index value to search for</param>
            <returns>Awaitable Task with list of found entities in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.LoadByKeyAsync``2(Lex.Db.DbTable{``0},``1)">
            <summary>
            Asynchronously loads entity by PK value 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="key">The PK value of entity to load</param>
            <returns>Awaitable Task with loaded entity in result, or null if not found</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.LoadByKeysAsync``2(Lex.Db.DbTable{``0},System.Collections.Generic.IEnumerable{``1},System.Boolean)">
            <summary>
            Asynchronously loads entities with speicified PK values 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="keys">The enumeration of PK values to load</param>
            <param name="yieldNotFound">Specifies that missing records should be ignored or returnes as nulls</param>
            <returns>Awaitable Task with enumeration of loaded entities in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.RefreshAsync``1(Lex.Db.DbTable{``0},``0)">
            <summary>
            Asynchronously reloads specified entity by its PK 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="item">Entity to reload from table</param>
            <returns>Awaitable Task with reloaded entity in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.SaveAsync``1(Lex.Db.DbTable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Asynchronously saves specified entities 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="items">Enumeration of entities to save</param>
            <returns>Awaitable Task of the save operation</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.SaveAsync``1(Lex.Db.DbTable{``0},``0)">
            <summary>
            Asynchronously saves specified entity 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="item">Entity to save</param>
            <returns>Awaitable Task of the save operation</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.DeleteByKeyAsync``1(Lex.Db.DbTable,``0)">
            <summary>
            Asynchronously deletes specified entity by PK supplied 
            </summary>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="key">The PK value</param>
            <returns>Awaitable Task with success flag in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.DeleteByKeyAsync``1(Lex.Db.DbTable,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Asynchronously deletes specified entities by their PKs 
            </summary>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="keys">The enumeration of PK values</param>
            <returns>Awaitable Task with count of successfully deleted entities in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.DeleteAsync``1(Lex.Db.DbTable{``0},``0)">
            <summary>
            Asynchronously deletes specified entity 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="item">Entity to delete</param>
            <returns>Awaitable Task with success flag in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.DeleteAsync``1(Lex.Db.DbTable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Asynchronously deletes specified entities 
            </summary>
            <typeparam name="T">Type of the entity class</typeparam>
            <param name="table">Table of the entity class</param>
            <param name="items">Entities to delete</param>
            <returns>Awaitable Task with count of successfully deleted entities in result</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.InitializeAsync(Lex.Db.DbInstance)">
            <summary>
            Asynchronously initializes database instance 
            </summary>
            <param name="db">Database instance to initialize</param>
            <returns>Awaitable Task of initialize operation</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.PurgeAsync(Lex.Db.DbTable)">
            <summary>
            Asynchronously purges specified table
            </summary>
            <param name="table">Table to purge</param>
            <returns>Awaitable Task of purge operation</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.PurgeAsync(Lex.Db.DbInstance)">
            <summary>
            Asynchronously purges specified database instance
            </summary>
            <param name="db">Database instance to purge</param>
            <returns>Awaitable Task of purge operation</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.CompactAsync(Lex.Db.DbTable)">
            <summary>
            Asynchronously compacts specified table
            </summary>
            <param name="table">Table to compact</param>
            <returns>Awaitable Task of compact operation</returns>
        </member>
        <member name="M:Lex.Db.DbTableAsync.CompactAsync(Lex.Db.DbInstance)">
            <summary>
            Asynchronously compacts specified database instance
            </summary>
            <param name="db">Database instance to compact</param>
            <returns>Awaitable Task of compact operation</returns>
        </member>
        <member name="T:System.Threading.ReaderWriterLockSlim">
            <summary>
            A reader-writer lock implementation that is intended to be simple, yet very 
            efficient.  In particular only 1 interlocked operation is taken for any lock
            operation (we use spin locks to achieve this).  The spin lock is never held 
            for more than a few instructions (in particular, we never call event APIs 
            or in fact any non-trivial API while holding the spin lock).
            </summary> 
        </member>
        <member name="M:System.Threading.ReaderWriterLockSlim.GetThreadRWCount(System.Int32,System.Boolean)">
            <summary> 
            This routine retrieves/sets the per-thread counts needed to enforce the
            various rules related to acquiring the lock. It's a simple hash table, 
            where the first entry is pre-allocated for optimizing the common case.
            After the first element has been allocated, duplicates are kept of in
            linked-list. The entries are never freed, and the max size of the
            table would be bounded by the max number of threads that held the lock 
            simultaneously.
            
            DontAllocate is set to true if the caller just wants to get an existing 
            entry for this thread, but doesn't want to add one if an existing one
            could not be found. 
            </summary>
        </member>
        <member name="M:System.Threading.ReaderWriterLockSlim.LazyCreateEvent(System.Threading.EventWaitHandle@,System.Boolean)">
            <summary>
            A routine for lazily creating a event outside the lock (so if errors 
            happen they are outside the lock and that we don't do much work
            while holding a spin lock).  If all goes well, reenter the lock and
            set 'waitEvent'
            </summary> 
        </member>
        <member name="M:System.Threading.ReaderWriterLockSlim.WaitOnEvent(System.Threading.EventWaitHandle,System.UInt32@,System.Int32)">
            <summary> 
            Waits on 'waitEvent' with a timeout of 'millisceondsTimeout. 
            Before the wait 'numWaiters' is incremented and is restored before leaving this routine.
            </summary> 
        </member>
        <member name="M:System.Threading.ReaderWriterLockSlim.ExitAndWakeUpAppropriateWaiters">
            <summary> 
            Determines the appropriate events to set, leaves the locks, and sets the events. 
            </summary>
        </member>
        <member name="T:Lex.Db.Lazy`1">
            <summary>
            Provides support for lazy initialization
            </summary>
            <typeparam name="T">Specifies the type of entity that is being lazily initialized</typeparam>
        </member>
        <member name="M:Lex.Db.Lazy`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the Lazy class. When lazy initialization occurs, the specified initialization function is used.
            </summary>
            <param name="loader">The delegate that is invoked to produce the lazily initialized value when it is needed</param>
        </member>
        <member name="P:Lex.Db.Lazy`1.Value">
            <summary>
            Gets the lazily loaded entity of the current Lazy instance.
            </summary>
        </member>
        <member name="T:Lex.Db.Lazy`2">
            <summary>
            Provides support for lazy entity loading as well as access to index value concisting from one component
            </summary>
            <typeparam name="T">Specifies the type of entity that is being lazily loaded</typeparam>
            <typeparam name="I1">Type of the index component</typeparam>
        </member>
        <member name="P:Lex.Db.Lazy`2.Key">
            <summary>
            Index component
            </summary>
        </member>
        <member name="T:Lex.Db.Lazy`3">
            <summary>
            Provides support for lazy entity loading as well as access to index value concisting from two components
            </summary>
            <typeparam name="T">Specifies the type of entity that is being lazily loaded</typeparam>
            <typeparam name="I1">Type of the first index component</typeparam>
            <typeparam name="I2">Type of the second index component</typeparam>
        </member>
        <member name="P:Lex.Db.Lazy`3.Key1">
            <summary>
            First index component
            </summary>
        </member>
        <member name="P:Lex.Db.Lazy`3.Key2">
            <summary>
            Second index component
            </summary>
        </member>
        <member name="T:Lex.Db.Lazy`4">
            <summary>
            Provides support for lazy entity loading as well as access to index value concisting from three components
            </summary>
            <typeparam name="T">Specifies the type of entity that is being lazily loaded</typeparam>
            <typeparam name="I1">Type of the first index component</typeparam>
            <typeparam name="I2">Type of the second index component</typeparam>
            <typeparam name="I3">Type of the third index component</typeparam>
        </member>
        <member name="P:Lex.Db.Lazy`4.Key1">
            <summary>
            First index component
            </summary>
        </member>
        <member name="P:Lex.Db.Lazy`4.Key2">
            <summary>
            Second index component
            </summary>
        </member>
        <member name="P:Lex.Db.Lazy`4.Key3">
            <summary>
            Third index component
            </summary>
        </member>
        <member name="T:Lex.Db.Indexing.RBTreeColor">
            <summary>
            Colour of the node
            </summary>
        </member>
        <member name="F:Lex.Db.Indexing.RBTreeColor.Red">
            <summary>
            Red
            </summary>
        </member>
        <member name="F:Lex.Db.Indexing.RBTreeColor.Black">
            <summary>
            Black
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Clear">
            <summary>
            Remove all items
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Add(`0)">
            <summary>
            Add new key into the tree
            
            This operation is O(logN) operation
            </summary>
            <exception cref="T:System.ArgumentException">In case the key is already in the tree</exception>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.AddOrGet(`0)">
            <summary>
            Add new key into the tree or get existing node
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Remove(`0)">
            <summary>
            Remove key from the dictionary
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Remove(`1)">
            <summary>
            Remove node from the dictionary
            This operation is O(1) operation
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Delete(`1)">
            <summary>
            Delete the node z, and free up the space
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.DeleteFix(`1)">
            <summary>
            Restore the reb-black properties after a delete
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Find(`0)">
            <summary>
            Find key in the dictionary
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Traverse(`0,System.Boolean@)">
            <summary>
            Go trough tree and find the node by the key.
            Might add new node if node doesn't exist.
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Balance(`1)">
            <summary>
            Balance tree past inserting
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Next(`1)">
            <summary>
            Return a pointer to the smallest key greater than x
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Prev(`1)">
            <summary>
            Return a pointer to the largest key smaller than x
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.First">
            <summary>
            Get first node
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Lex.Db.Indexing.RBTree`2.Last">
            <summary>
            Get last node
            This operation is O(logN) operation
            </summary>
        </member>
        <member name="M:Lex.Db.Mapping.Metadata`1.MakeWriteMethod">
            <summary>
            foreach(var property in properties) 
              if (Interceptor.NeedSerialize(T, property.Name)
              {
                WritePropertyId();
                WritePropertyValue();
              }
            WritePropertyId(-1);
            </summary>
        </member>
        <member name="T:Lex.Db.TypeMap">
            <summary>
            Entity type to table mapping base
            </summary>
        </member>
        <member name="P:Lex.Db.TypeMap.Name">
            <summary>
            Indicates name of the table
            </summary>
        </member>
        <member name="T:Lex.Db.TypeMap`1">
            <summary>
            Entity type to table mapping
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lex.Db.TypeMap`1.ToTable(System.String)">
            <summary>
            Defines a non-default name of the entity table
            </summary>
            <param name="name">Name of the table file without extension</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.Reset">
            <summary>
            Resets all mappings
            </summary>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.WithInterceptor(Lex.Db.Serialization.Interceptor{`0})">
            <summary>
            Registers interceptor to control serialization of properties
            </summary>
            <param name="interceptor">Custom interceptor implementation</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.WithInterceptor(System.Func{`0,System.String,System.Nullable{System.Boolean}})">
            <summary>
            Registers interceptor function to control serialization of properties
            </summary>
            <param name="interceptor">Custom interceptor function</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.Key``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Defines primary key expression, indicating optional automatic generation of PK values
            </summary>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="keyBuilder">Primary key expression</param>
            <param name="autoGen">Indicates automatic generation of PK values (int, long, Guid types only)</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.Automap``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Defines complete mapping for public properties and fields via reflection, 
            with specified primary key expression and optional automatic generation
            </summary>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="keyBuilder">Primary key expression</param>
            <param name="autoGen">Indicates automatic generation of PK values (int, long, Guid types only)</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.MapAll">
            <summary>
            Defines complete mapping for public properties and fields via reflection
            </summary>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.Unmap``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Removes mapping for specified member
            </summary>
            <typeparam name="K">Type of the member</typeparam>
            <param name="property">Member access expression</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Adds mapping for specified member
            </summary>
            <typeparam name="K">Type of the member</typeparam>
            <param name="property">Members access expression (public readable/writable property or field)</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.WithIndex``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Collections.Generic.IComparer{``0})">
            <summary>
            Adds non-unique typed index over single component
            </summary>
            <typeparam name="I1">Type of the index key</typeparam>
            <param name="name">Name of the index</param>
            <param name="indexBy">Indexing expression</param>
            <param name="comparer">Optional comparer for indexing expression</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.WithIndex``2(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,``1}},System.Collections.Generic.IComparer{``0},System.Collections.Generic.IComparer{``1})">
            <summary>
            Adds non-unique typed index over two components
            </summary>
            <typeparam name="I1">Type of the first index key component</typeparam>
            <typeparam name="I2">Type of the second index key component</typeparam>
            <param name="name">Name of the index</param>
            <param name="indexBy">First index key component expression</param>
            <param name="thenBy">Second index key component expression</param>
            <param name="comparerIndexBy">Optional comparer for first index key component</param>
            <param name="comparerThenBy">Optional comparer for second index key component</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="M:Lex.Db.TypeMap`1.WithIndex``3(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,``1}},System.Linq.Expressions.Expression{System.Func{`0,``2}},System.Collections.Generic.IComparer{``0},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IComparer{``2})">
            <summary>
            Adds non-unique typed index over three components
            </summary>
            <typeparam name="I1">Type of the first index key component</typeparam>
            <typeparam name="I2">Type of the second index key component</typeparam>
            <typeparam name="I3">Type of the third index key component</typeparam>
            <param name="name">Name of the index</param>
            <param name="indexBy">First index key component expression</param>
            <param name="thenBy">Second index key component expression</param>
            <param name="andThenBy">Third index key component expression</param>
            <param name="comparerIndexBy">Optional comparer for first index key component</param>
            <param name="comparerThenBy">Optional comparer for second index key component</param>
            <param name="comparerAndThenBy">Optional comparer for thirt index key component</param>
            <returns>Entity type mapping to continue with</returns>
        </member>
        <member name="P:Lex.Db.TypeMap`1.Name">
            <summary>
            Indicates name of the table
            </summary>
        </member>
        <member name="T:Lex.Db.Serialization.Interceptor`1">
            <summary>
            Incapsulates logic to decide which members should be serialized
            </summary>
            <typeparam name="T">Entity type</typeparam>
        </member>
        <member name="M:Lex.Db.Serialization.Interceptor`1.NeedSerialize(`0,System.String)">
            <summary>
            Implements deciding logic whether member should be stored in table or not
            </summary>
            <param name="instance">Entity instance to inspect</param>
            <param name="member">Name of the member to serialize</param>
            <returns>True is member should be serialized, false otherwise</returns>
        </member>
        <member name="T:Lex.Db.Serialization.Extender">
            <summary>
            Serialization extender
            </summary>
        </member>
        <member name="M:Lex.Db.Serialization.Extender.RegisterType``2(System.Int16)">
            <summary>
            Registers static serialization extension before any DbInstance initialization.
            Serialization extensions is a static class with following methods pattern:
            public static K ReadXXX(DataReader reader)
            public static void WriteXXX(DataWriter writer, K value)
            where K is custom type to serialize
            XXX is type name of K without namespace
            </summary>
            <typeparam name="K">Type to serialize</typeparam>
            <typeparam name="S">Serialization extension</typeparam>
            <param name="streamId">Stable (for the lifetime of your app) id of the custom type. 
            Must be greater than 1000 (other are already taken or reserved for future use)</param>
        </member>
        <member name="T:Lex.Db.Serialization.Serializers">
            <summary>
            Provides serialization logic and code generation
            </summary>
        </member>
        <member name="T:Lex.Db.Serialization.DataReader">
            <summary>
            Extended binary reader 
            </summary>
        </member>
        <member name="M:Lex.Db.Serialization.DataReader.#ctor(System.IO.Stream)">
            <summary>
            Creates DataReader with specified owned stream
            </summary>
            <param name="stream">Stream to read from</param>
        </member>
        <member name="M:Lex.Db.Serialization.DataReader.ReadTimeSpan">
            <summary>
            Reads TimeSpan value from stream
            </summary>
            <returns>TimeSpan value</returns>
        </member>
        <member name="M:Lex.Db.Serialization.DataReader.ReadDateTime">
            <summary>
            Reads DateTime value from stream
            </summary>
            <returns>DateTime value</returns>
        </member>
        <member name="M:Lex.Db.Serialization.DataReader.ReadDateTimeOffset">
            <summary>
            Reads DateTimeOffset value from stream
            </summary>
            <returns>DateTimeOffset value</returns>
        </member>
        <member name="M:Lex.Db.Serialization.DataReader.ReadGuid">
            <summary>
            Reads Guid value from stream
            </summary>
            <returns>Guid value</returns>
        </member>
        <member name="M:Lex.Db.Serialization.DataReader.ReadArray">
            <summary>
            Reads byte array from stream
            </summary>
            <returns>Byte array</returns>
        </member>
        <member name="M:Lex.Db.Serialization.DataReader.ReadDecimal">
            <summary>
            Reads Decimal value from stream
            </summary>
            <returns>Decimal value</returns>
        </member>
        <member name="M:Lex.Db.Serialization.DataReader.LoadReference``2(``1)">
            <summary>
            Loads referenced entity of specified entity type and specified PK value
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="key">PK value</param>
            <returns>Entity with specified PK value or null if not found</returns>
        </member>
        <member name="T:Lex.Db.Serialization.DataWriter">
            <summary>
            Extended binary writer
            </summary>
        </member>
        <member name="M:Lex.Db.Serialization.DataWriter.#ctor(System.IO.Stream)">
            <summary>
            Creates DataWriter with specified owned stream
            </summary>
            <param name="stream">Stream to write to</param>
        </member>
        <member name="M:Lex.Db.Serialization.DataWriter.SaveReference``2(``0)">
            <summary>
            Saves reference to specified entity and returns its PK value
            </summary>
            <typeparam name="T">Type of the entity</typeparam>
            <typeparam name="K">Type of the PK</typeparam>
            <param name="reference">Entity to save reference to</param>
            <returns>PK value of the referenced entity</returns>
        </member>
        <member name="M:Lex.Db.Serialization.DataWriter.Write(System.TimeSpan)">
            <summary>
            Writes TimeSpan value to stream
            </summary>
            <param name="value">TimeSpan value to write</param>
        </member>
        <member name="M:Lex.Db.Serialization.DataWriter.Write(System.DateTime)">
            <summary>
            Writes DateTime value to stream
            </summary>
            <param name="value">DateTime value to write</param>
        </member>
        <member name="M:Lex.Db.Serialization.DataWriter.Write(System.DateTimeOffset)">
            <summary>
            Writes DateTimeOffset value to stream
            </summary>
            <param name="value">DateTimeOffset value to write</param>
        </member>
        <member name="M:Lex.Db.Serialization.DataWriter.Write(System.Guid)">
            <summary>
            Writes Guid value to stream
            </summary>
            <param name="value">Guid value to write</param>
        </member>
        <member name="M:Lex.Db.Serialization.DataWriter.WriteDecimal(System.Decimal)">
            <summary>
            Writes Decimal value to stream
            </summary>
            <param name="value">Decimal value to write</param>
        </member>
        <member name="M:Lex.Db.Serialization.DataWriter.WriteArray(System.Byte[])">
            <summary>
            Writes byte array to stream
            </summary>
            <param name="value">Byte array to write</param>
        </member>
    </members>
</doc>
